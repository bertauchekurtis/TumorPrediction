abline(a = 0, b = 1)
data <- read.csv(file = "C:/Users/kbertauche/Downloads/RetentionTime_HCD_Marx2013_SuppT3.csv")
data <- read.csv(file = "C:/Users/Kurtis/Desktop/Research/data/RetentionTime_HCD_Marx2013_SuppT3.csv")
set.seed(37)
library(stringr)
library(xgboost)
encode = function(data)
{
data$peptideLength <- nchar(data$Peptide.Sequence2)
data$unmodA <- str_count(data$Peptide.Sequence2, "A")
data$unmodC <- str_count(data$Peptide.Sequence2, "C")
data$unmodD <- str_count(data$Peptide.Sequence2, "D")
data$unmodE <- str_count(data$Peptide.Sequence2, "E")
data$unmodF <- str_count(data$Peptide.Sequence2, "F")
data$unmodG <- str_count(data$Peptide.Sequence2, "G")
data$unmodH <- str_count(data$Peptide.Sequence2, "H")
data$unmodI <- str_count(data$Peptide.Sequence2, "I")
data$unmodK <- str_count(data$Peptide.Sequence2, "K")
data$unmodL <- str_count(data$Peptide.Sequence2, "L")
data$unmodM <- str_count(data$Peptide.Sequence2, "M")
data$unmodN <- str_count(data$Peptide.Sequence2, "N")
data$unmodP <- str_count(data$Peptide.Sequence2, "P")
data$unmodQ <- str_count(data$Peptide.Sequence2, "Q")
data$unmodR <- str_count(data$Peptide.Sequence2, "R")
data$unmodS <- str_count(data$Peptide.Sequence2, "S")
data$unmodT <- str_count(data$Peptide.Sequence2, "T")
data$unmodV <- str_count(data$Peptide.Sequence2, "V")
data$unmodW <- str_count(data$Peptide.Sequence2, "W")
data$unmodY <- str_count(data$Peptide.Sequence2, "Y")
data$modS <- str_count(data$Peptide.Sequence2, "s")
data$modT <- str_count(data$Peptide.Sequence2, "t")
data$modY <- str_count(data$Peptide.Sequence2, "y")
data$modM <- str_count(data$Peptide.Sequence2, "m")
data
}
data <- encode(data)
# remove non-numeric data
data$Peptide.Sequence2 <- NULL
# split data into training/testing sets
setAssignments <- sample(1:2, size = nrow(data), prob = c(0.8, 0.2), replace = TRUE)
trainingData <- data[setAssignments == 1,]
testingData <- data[setAssignments == 2,]
# exract retention times (output) from data
trainingRetentionTimesLabels <- trainingData$RetentionTime
trainingData$RetentionTime <- NULL
# xg boost matrix creation
trainingxgMatrix <- xgb.DMatrix(data.matrix(trainingData), label = trainingRetentionTimesLabels)
# for testing
testingDataLabels <- testingData$RetentionTime
testingData$RetentionTime <- NULL
testingxgMatrix <- xgb.DMatrix(data.matrix(testingData), label = testingDataLabels)
# analyze things
set.seed(37)
bestModel <-xgboost(booster = "gbtree",
objective = "reg:squarederror",
gamma = 0.2,
child_weight = 1,
max_depth = 11,
subsample = 0.9,
col_subsample = 1,
eta = 0.01,
nrounds = 10000,
nthreads = 28,
print_every_n = 2500,
early_stopping_rounds = 2,
data = trainingxgMatrix)
predictions <- predict(bestModel, testingxgMatrix)
residual <- testingDataLabels - predictions
print("RMSE:") # RMSE calculation
sqrt(mean(((residual))^2))
data <- read.csv(file = "C:/Users/Kurtis/Desktop/Research/data/RetentionTime_HCD_Marx2013_SuppT3.csv")
data <- read.csv(file = "C:/Users/Kurtis/Desktop/Research/data/RetentionTime_HCD_Marx2013_SuppT3.csv")
data2 <- read.csv(file = "C:/Users/Kurtis/Desktop/Research/RScripts/Updated/dataSetTwoFiltered.csv")
data2$X <- NULL
colnames(data2) <- c("Peptide.Sequence2", "RetentionTime")
set.seed(37)
library(stringr)
library(xgboost)
# predictor variables
encode = function(data)
{
data$peptideLength <- nchar(data$Peptide.Sequence2)
data$unmodA <- str_count(data$Peptide.Sequence2, "A")
data$unmodC <- str_count(data$Peptide.Sequence2, "C")
data$unmodD <- str_count(data$Peptide.Sequence2, "D")
data$unmodE <- str_count(data$Peptide.Sequence2, "E")
data$unmodF <- str_count(data$Peptide.Sequence2, "F")
data$unmodG <- str_count(data$Peptide.Sequence2, "G")
data$unmodH <- str_count(data$Peptide.Sequence2, "H")
data$unmodI <- str_count(data$Peptide.Sequence2, "I")
data$unmodK <- str_count(data$Peptide.Sequence2, "K")
data$unmodL <- str_count(data$Peptide.Sequence2, "L")
data$unmodM <- str_count(data$Peptide.Sequence2, "M")
data$unmodN <- str_count(data$Peptide.Sequence2, "N")
data$unmodP <- str_count(data$Peptide.Sequence2, "P")
data$unmodQ <- str_count(data$Peptide.Sequence2, "Q")
data$unmodR <- str_count(data$Peptide.Sequence2, "R")
data$unmodS <- str_count(data$Peptide.Sequence2, "S")
data$unmodT <- str_count(data$Peptide.Sequence2, "T")
data$unmodV <- str_count(data$Peptide.Sequence2, "V")
data$unmodW <- str_count(data$Peptide.Sequence2, "W")
data$unmodY <- str_count(data$Peptide.Sequence2, "Y")
data$modS <- str_count(data$Peptide.Sequence2, "s")
data$modT <- str_count(data$Peptide.Sequence2, "t")
data$modY <- str_count(data$Peptide.Sequence2, "y")
data$modM <- str_count(data$Peptide.Sequence2, "m")
data
}
data <- encode(data)
data2 <- encode(data2)
# remove non-numeric data
data$Peptide.Sequence2 <- NULL
data2$Peptide.Sequence2 <- NULL
# split data into training/testing sets
setAssignments <- sample(1:2, size = nrow(data), prob = c(0.8, 0.2), replace = TRUE)
trainingData <- data[setAssignments == 1,]
testingData <- data[setAssignments == 2,]
setAssignments2 <- sample(1:2, size = nrow(data2), prob = c(0.8, 0.2), replace = TRUE)
trainingData2 <- data2[setAssignments2 == 1]
trainingData2 <- data2[setAssignments2 == 1,]
testingData2 <- data2[setAssignments2 == 2,]
# exract retention times (output) from data
trainingRetentionTimesLabels <- trainingData$RetentionTime
trainingData$RetentionTime <- NULL
training2RetentionTimesLabels <- trainingData2$RetentionTime
trainingData2$RetentionTime <- NULL
# xg boost matrix creation
trainingxgMatrix <- xgb.DMatrix(data.matrix(trainingData), label = trainingRetentionTimesLabels)
training2xgMatrix <- xgb.DMatrix(data.matrix(trainingData2), label = training2RetentionTimesLabels)
# for testing
testingDataLabels <- testingData$RetentionTime
testingData$RetentionTime <- NULL
testingxgMatrix <- xgb.DMatrix(data.matrix(testingData), label = testingDataLabels)
testing2DataLabels <- testingData2$RetentionTime
testingData2$RetentionTime <- NULL
testing2xgMatrix <- xgb.DMatrix(data.matrix(testingData2), label = testing2DataLabels)
bestModel <-xgboost(booster = "gbtree",
objective = "reg:squarederror",
gamma = 0.2,
child_weight = 1,
max_depth = 11,
subsample = 0.9,
col_subsample = 1,
eta = 0.01,
nrounds = 10000,
nthreads = 28,
print_every_n = 2500,
early_stopping_rounds = 2,
data = trainingxgMatrix)
bestModel2 <- xgboost(booster = "gbtree",
objective = "reg:squarederror",
gamma = 0.3,
child_weight = 1,
max_depth = 9,
subsample = 0.8,
col_subsample = 1,
eta = 0.01,
nrounds = 10000,
nthreads = 28,
print_every_n = 2500,
early_stopping_rounds = 2,
data = training2xgMatrix)
predictions <- predict(bestModel, testingxgMatrix)
residual <- testingDataLabels - predictions
print("RMSE:") # RMSE calculation
sqrt(mean(((residual))^2))
print("MAE:")# MAE calculation
mean(abs(residual))
# calculate 95% error window size
q <- quantile(residual, probs =c(.025,.975))
abs(q[1]) + abs(q[2]) # total length of window
cor(testingDataLabels, predictions)
predictions2 <- predict(bestModel2, testing2xgMatrix)
residual2 <- testing2DataLabels - predictions2
print("RMSE:") # RMSE calculation
sqrt(mean(((residual2))^2))
print("MAE:")# MAE calculation
mean(abs(residual2))
data <- read.csv(file = "C:/Users/Kurtis/Desktop/Research/data/RetentionTime_HCD_Marx2013_SuppT3.csv")
set.seed(37)
library(stringr)
library(xgboost)
# predictor variables
encode = function(data)
{
data$peptideLength <- nchar(data$Peptide.Sequence2)
data$unmodA <- str_count(data$Peptide.Sequence2, "A")
data$unmodC <- str_count(data$Peptide.Sequence2, "C")
data$unmodD <- str_count(data$Peptide.Sequence2, "D")
data$unmodE <- str_count(data$Peptide.Sequence2, "E")
data$unmodF <- str_count(data$Peptide.Sequence2, "F")
data$unmodG <- str_count(data$Peptide.Sequence2, "G")
data$unmodH <- str_count(data$Peptide.Sequence2, "H")
data$unmodI <- str_count(data$Peptide.Sequence2, "I")
data$unmodK <- str_count(data$Peptide.Sequence2, "K")
data$unmodL <- str_count(data$Peptide.Sequence2, "L")
data$unmodM <- str_count(data$Peptide.Sequence2, "M")
data$unmodN <- str_count(data$Peptide.Sequence2, "N")
data$unmodP <- str_count(data$Peptide.Sequence2, "P")
data$unmodQ <- str_count(data$Peptide.Sequence2, "Q")
data$unmodR <- str_count(data$Peptide.Sequence2, "R")
data$unmodS <- str_count(data$Peptide.Sequence2, "S")
data$unmodT <- str_count(data$Peptide.Sequence2, "T")
data$unmodV <- str_count(data$Peptide.Sequence2, "V")
data$unmodW <- str_count(data$Peptide.Sequence2, "W")
data$unmodY <- str_count(data$Peptide.Sequence2, "Y")
data$modS <- str_count(data$Peptide.Sequence2, "s")
data$modT <- str_count(data$Peptide.Sequence2, "t")
data$modY <- str_count(data$Peptide.Sequence2, "y")
data$modM <- str_count(data$Peptide.Sequence2, "m")
data
}
data <- encode(data)
# remove non-numeric data
data$Peptide.Sequence2 <- NULL
# split data into training/testing sets
setAssignments <- sample(1:2, size = nrow(data), prob = c(0.8, 0.2), replace = TRUE)
trainingData <- data[setAssignments == 1,]
testingData <- data[setAssignments == 2,]
# exract retention times (output) from data
trainingRetentionTimesLabels <- trainingData$RetentionTime
trainingData$RetentionTime <- NULL
# xg boost matrix creation
trainingxgMatrix <- xgb.DMatrix(data.matrix(trainingData), label = trainingRetentionTimesLabels)
# for testing
testingDataLabels <- testingData$RetentionTime
testingData$RetentionTime <- NULL
testingxgMatrix <- xgb.DMatrix(data.matrix(testingData), label = testingDataLabels)
# analyze things
set.seed(37)
bestModel <-xgboost(booster = "gbtree",
objective = "reg:squarederror",
gamma = 0.2,
child_weight = 1,
max_depth = 11,
subsample = 0.9,
col_subsample = 1,
eta = 0.01,
nrounds = 10000,
nthreads = 28,
print_every_n = 2500,
early_stopping_rounds = 2,
data = trainingxgMatrix)
predictions <- predict(bestModel, testingxgMatrix)
residual <- testingDataLabels - predictions
print("RMSE:") # RMSE calculation
sqrt(mean(((residual))^2))
print("MAE:")# MAE calculation
mean(abs(residual))
# calculate 95% error window size
q <- quantile(residual, probs =c(.025,.975))
abs(q[1]) + abs(q[2]) # total length of window
cor(testingDataLabels, predictions)
print("RMSE:") # RMSE calculation
sqrt(mean(((residual))^2))
print("MAE:")# MAE calculation
mean(abs(residual))
# calculate 95% error window size
q <- quantile(residual, probs =c(.025,.975))
abs(q[1]) + abs(q[2]) # total length of window
cor(testingDataLabels, predictions)
# PREDICTIONS - TRAIN DATA ONE TEST DATA TWO
predictions_m1d2 <- predict(bestModel, testing2xgMatrix)
residual_m1d2 <- testing2DataLabels - predictions_m1d2
print("RMSE:")
sqrt(mean((residual_m1d2))^2)
print("MAE:")
mean(abs(residual_m1d2))
q <- quantile(residual_m1d2, probs = c(.025, .975))
abs(q[1]) + abs(q[2])
cor(testing2DataLabels, predictions_m1d2)
# PREDICTIONS - TRAIN DATA ONE TEST DATA TWO
predictions_m1d2 <- predict(bestModel, testing2xgMatrix)
residual_m1d2 <- testing2DataLabels - predictions_m1d2
print("RMSE:")
sqrt(mean((residual_m1d2))^2)
print("MAE:")
mean(abs(residual_m1d2))
q <- quantile(residual_m1d2, probs = c(.025, .975))
abs(q[1]) + abs(q[2])
set.seed(37)
# PREDICTIONS - TRAIN DATA 2 TEST DATA 2
predictions2 <- predict(bestModel2, testing2xgMatrix)
residual2 <- testing2DataLabels - predictions2
print("RMSE:") # RMSE calculation
sqrt(mean(((residual2))^2))
print("MAE:")# MAE calculation
mean(abs(residual2))
# calculate 95% error window sizes
q <- quantile(residual2, probs =c(.025,.975))
abs(q[1]) + abs(q[2]) # total length of window
cor(testing2DataLabels, predictions2)
# PREDICTIONS - TRAIN DATA 2 TEST DATA 1
predictions_m2d1 <- predict(bestModel2, testingxgMatrix)
residual_m2d1 <- testingDataLabels - predictions_m2d1
print("RMSE:") # RMSE calculation
sqrt(mean(((residual_m2d1))^2))
print("MAE:")# MAE calculation
mean(abs(residual_m2d1))
# calculate 95% error window sizes
q <- quantile(residual_m2d1, probs =c(.025,.975))
abs(q[1]) + abs(q[2]) # total length of window
cor(testingDataLabels, predictions_m2d1)
sqrt(mean((residual_m1d2))^2)
residual_m2d1 <- testingDataLabels - predictions_m2d1
print("RMSE:") # RMSE calculation
sqrt(mean(((residual_m2d1))^2))
residual2 <- testing2DataLabels - predictions2
print("RMSE:") # RMSE calculation
sqrt(mean(((residual2))^2))
# PREDICTIONS - TRAIN DATA ONE TEST DATA TWO
predictions_m1d2 <- predict(bestModel, testing2xgMatrix)
residual_m1d2 <- testing2DataLabels - predictions_m1d2
print("RMSE:")
sqrt(mean((residual_m1d2))^2)
modelA <- bestModel
dataB_xgMat_train <- training2xgMatrix
predicts_of_train_B_from_model_A <- predict(modelA, dataB_xgbMat_train)
dataB_xgbMat_train <- training2xgMatrix
predicts_of_train_B_from_model_A <- predict(modelA, dataB_xgbMat_train)
length(predicts_of_train_B_from_model_A)
dataB_train_labels <- training2RetentionTimesLabels
dataB_test_labels <- testing2DataLabels
df <- data.frame(dataB_train_labels, predicts_of_train_B_from_model_A)
newLM <- lm(dataB_train_labels ~ predicts_of_train_B_from_model_A, data = df)
predicts_of_test_B_from_model_A <- predict(modelA, dataB_xgbMat_test)
dataB_xgbMat_test <- testing2xgMatrix
predicts_of_test_B_from_model_A <- predict(modelA, dataB_xgbMat_test)
df2 <- data.frame(predicts_of_test_B_from_model_A)
colnames(df2) <- c("predicts_of_train_B_from_model_A")
predictions_z <- predict(newLM, df2)
# ALIGNMNETS
alignXGB = function(modelA, dataB_xgbMat_test, dataB_xgbMat_train, dataB_train_labels, dataB_test_labels)
{
predicts_of_train_B_from_model_A <- predict(modelA, dataB_xgbMat_train)
df <- data.frame(dataB_train_labels, predicts_of_train_B_from_model_A)
newLM <- lm(dataB_train_labels ~ predicts_of_train_B_from_model_A, data = df)
predicts_of_test_B_from_model_A <- predict(modelA, dataB_xgbMat_test)
df2 <- data.frame(predicts_of_test_B_from_model_A)
colnames(df2) <- c("predicts_of_train_B_from_model_A")
predictions_z <- predict(newLM, df2)
residual <- dataB_test_labels - predictions_z
q <- quantile(residual_m2d1, probs =c(.025,.975))
c(newLM$coefficients,
sqrt(mean(((residual))^2)),
mean(abs(residual_m2d1)),
abs(q[1]) + abs(q[2]),
cor(dataB_test_labels, predictions_z))
}
alignXGB(bestModel, testing2xgMatrix, training2xgMatrix, training2RetentionTimesLabels, testing2DataLabels)
alignXGB(bestModel2, testingxgMatrix, trainingxgMatrix, trainingRetentionTimesLabels, testingDataLabels)
modelA <- bestModel2
dataB_xgbMat_test <- testingxgMatrix
dataB_xgbMat_train <- trainingxgMatrix
dataB_train_labels <- trainingRetentionTimesLabels
dataB_test_labels <- testingDataLabels
predicts_of_train_B_from_model_A <- predict(modelA, dataB_xgbMat_train)
df <- data.frame(dataB_train_labels, predicts_of_train_B_from_model_A)
newLM <- lm(dataB_train_labels ~ predicts_of_train_B_from_model_A, data = df)
predicts_of_test_B_from_model_A <- predict(modelA, dataB_xgbMat_test)
df2 <- data.frame(predicts_of_test_B_from_model_A)
colnames(df2) <- c("predicts_of_train_B_from_model_A")
predictions_z <- predict(newLM, df2)
residual <- dataB_test_labels - predictions_z
q <- quantile(residual_m2d1, probs =c(.025,.975))
c(newLM$coefficients,
sqrt(mean(((residual))^2)),
mean(abs(residual_m2d1)),
abs(q[1]) + abs(q[2]),
cor(dataB_test_labels, predictions_z))
# ALIGNMNETS
alignXGB = function(modelA, dataB_xgbMat_test, dataB_xgbMat_train, dataB_train_labels, dataB_test_labels)
{
predicts_of_train_B_from_model_A <- predict(modelA, dataB_xgbMat_train)
df <- data.frame(dataB_train_labels, predicts_of_train_B_from_model_A)
newLM <- lm(dataB_train_labels ~ predicts_of_train_B_from_model_A, data = df)
predicts_of_test_B_from_model_A <- predict(modelA, dataB_xgbMat_test)
df2 <- data.frame(predicts_of_test_B_from_model_A)
colnames(df2) <- c("predicts_of_train_B_from_model_A")
predictions_z <- predict(newLM, df2)
residual <- dataB_test_labels - predictions_z
q <- quantile(residual, probs =c(.025,.975))
c(newLM$coefficients,
sqrt(mean(((residual))^2)),
mean(abs(residual)),
abs(q[1]) + abs(q[2]),
cor(dataB_test_labels, predictions_z))
}
alignXGB(bestModel, testing2xgMatrix, training2xgMatrix, training2RetentionTimesLabels, testing2DataLabels)
alignXGB(bestModel2, testingxgMatrix, trainingxgMatrix, trainingRetentionTimesLabels, testingDataLabels)
setwd("C:/Users/Kurtis/Desktop/TumorPrediction")
load("results/xgb_confusion_matrix.RData")
xgb_confusion_matrix
confusionMatrix <- xgb_confusion_matrix
confusion_matrix$overall[1]
confusion_matrix <- xgb_confusion_matrix
confusion_matrix$overall[1]
confusion_matrix$byClass[1]
confusion_matrix$byClass[2]
confusion_matrix$table[1]
confusion_matrix$table[2]
confusion_matrix$table[3]
confusion_matrix$table[4]
confusion_matrix$byClass[2]
confusion_matrix$byClass[3]
confusion_matrix$byClass[4]
confustion_matrix
confusion_matrix
install.packages(ROCR)
install.packages("ROCR")
library(ROCR)
load("models/lasso_model.RData")
library(glmnet)
test_data_glm_matrix <- model.matrix(Outcome ~ .,
test_data)[,-1]
test_data <- read.csv("data/clean/testing.csv")
test_data_glm_matrix <- model.matrix(Outcome ~ .,
test_data)[,-1]
lasso_predictions <- predict(lasso_model,
newx = test_data_glm_matrix,
type = "response")
calcMetrics <- function(confusion_matrix, predictions, labels)
{
accuracy <- confusion_matrix$overall[1]
sensitivity <- confusion_matrix$byClass[1]
specificity <- confusion_matrix$byClass[2]
false_positive_rate <- (confusion_matrix$table[2]/(confusion_matrix$table[2] + confusion_matrix$table[1]))
false_negative_rate <- (confusion_matrix$table[3]/(confusion_matrix$table[4]+confusion_matrix$table[3]))
positive_predictive_value <- confusion_matrix$byClass[3]
negative_predictive_value <- confusion_matrix$byClass[4]
positive_likelihood_ratio <- sensitivity / false_positive_rate
negative_likelihood_ratio <- false_negative_rate / specificity
diagnostic_odds_ratio <- positive_likelihood_ratio / negative_likelihood_ratio
f1_score <- (1 + 1^2) * ((sensitivity*positive_predictive_value)/(((1^2)*positive_predictive_value)+sensitivity))
f2_score <- (1 + 2^2) * ((sensitivity*positive_predictive_value)/(((2^2)*positive_predictive_value)+sensitivity))
youden_index <- sensitivity + specificity - 1
pred <- prediction(predictions, labels)
auc_perf <- performance(pred, measure = "auc")
area_under_roc_curve <- auc_perf@y.values
c(accuracy,
sensitivity,
specificity,
false_positive_rate,
false_negative_rate,
positive_predictive_value,
negative_predictive_value,
area_under_roc_curve,
positive_likelihood_ratio,
negative_likelihood_ratio,
diagnostic_odds_ratio,
f1_score,
f2_score,
youden_index)
}
load("results/lasso_confusion_matrix.RData")
calcMetrics(lasso_confusion_matrix,
lasso_predictions,
test_data$Outcome)
calcMetrics <- function(confusion_matrix, predictions, labels)
{
accuracy <- confusion_matrix$overall[1]
sensitivity <- confusion_matrix$byClass[1]
specificity <- confusion_matrix$byClass[2]
false_positive_rate <- (confusion_matrix$table[2]/(confusion_matrix$table[2] + confusion_matrix$table[1]))
false_negative_rate <- (confusion_matrix$table[3]/(confusion_matrix$table[4]+confusion_matrix$table[3]))
positive_predictive_value <- confusion_matrix$byClass[3]
negative_predictive_value <- confusion_matrix$byClass[4]
positive_likelihood_ratio <- sensitivity / false_positive_rate
negative_likelihood_ratio <- false_negative_rate / specificity
diagnostic_odds_ratio <- positive_likelihood_ratio / negative_likelihood_ratio
f1_score <- (1 + 1^2) * ((sensitivity*positive_predictive_value)/(((1^2)*positive_predictive_value)+sensitivity))
f2_score <- (1 + 2^2) * ((sensitivity*positive_predictive_value)/(((2^2)*positive_predictive_value)+sensitivity))
youden_index <- sensitivity + specificity - 1
pred <- prediction(predictions, labels)
auc_perf <- performance(pred, measure = "auc")
area_under_roc_curve <- auc_perf@y.values
returnFrame<- data.frame(accuracy = c(accuracy),
sensitivity = c(sensitivity),
specificity = c(specificity),
false_positive_rate = c(false_positive_rate),
false_negative_rate = c(false_negative_rate),
positive_predictive_value = c(positive_predictive_value),
negative_predictive_value = c(negative_predictive_value),
area_under_roc_curve = c(area_under_roc_curve),
positive_likelihood_ratio = c(positive_likelihood_ratio),
negative_likelihood_ratio = c(negative_likelihood_ratio),
diagnostic_odds_ratio = c(diagnostic_odds_ratio),
f1_score = c(f1_score),
f2_score = c(f2_score),
youden_index = c(youden_index))
return(returnFrame)
c(accuracy,
sensitivity,
specificity,
false_positive_rate,
false_negative_rate,
positive_predictive_value,
negative_predictive_value,
area_under_roc_curve,
positive_likelihood_ratio,
negative_likelihood_ratio,
diagnostic_odds_ratio,
f1_score,
f2_score,
youden_index)
}
hm <- calcMetrics(lasso_confusion_matrix,
lasso_predictions,
test_data$Outcome)
hm
lasso_confusion_matrix
View(hm)
